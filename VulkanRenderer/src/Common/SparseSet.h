#pragma once

#include "SparseSetGenerationTraits.h"
#include "types.h"
#include "Core/core.h"
#include "Core/Random.h"

#include "utils/MathUtils.h"

/* Paged sparse set implementation */

static constexpr u32 SPARSE_SET_PAGE_SIZE = 256;
static_assert(MathUtils::isPowerOf2(SPARSE_SET_PAGE_SIZE), "Page size must be a power of 2");
static const u32 SPARSE_SET_PAGE_SIZE_LOG = MathUtils::log2(SPARSE_SET_PAGE_SIZE);

/* ST - sparse type, DT - dense type*/
template <typename St, typename Dt>
class SparseSet
{
    using Traits = SparseSetGenerationTraits<Dt>;
    using SparseSetPage = std::vector<St>;
    struct Iterator
    {
        using iterator_category = std::forward_iterator_tag;
        using difference_type = i32;
        using value_type = Dt;
        using pointer = value_type*;
        using reference = value_type&;

        Iterator(std::vector<Dt>& dense, u32 index) : m_Index(index), m_Dense(&dense) { }
            
        reference operator*() const { return m_Dense->at(m_Index); }
        pointer operator->() { return &m_Dense->at(m_Index); }
        Iterator operator++() { m_Index--; return *this; }
        friend bool operator==(const Iterator& a, const Iterator& b) { return a.m_Index == b.m_Index; }
        friend bool operator!=(const Iterator& a, const Iterator& b) { return !(a == b); }
    private:
        u32 m_Index;
        std::vector<Dt>* m_Dense;
    };
public:
    static constexpr St NON_ELEMENT = std::numeric_limits<St>::max();
public:
    constexpr SparseSet() = default;
    
    constexpr St Push(Dt value);
    template <typename PushCallback>
    constexpr St Push(Dt value, PushCallback callback = [](St){});
    
    constexpr void Pop(Dt value);
    template <typename PopCallback, typename SwapCallback>
    constexpr void Pop(Dt value, PopCallback popCallback = [](St){}, SwapCallback swapCallback = [](St, St) {});
    
    /* checks if the value, that was generated by this set, still belongs to it */ 
    constexpr bool Has(Dt value) const;

    constexpr St GetIndexOf(Dt value) const;
        
    constexpr Dt& operator[](Dt value);
    constexpr const Dt& operator[](Dt value) const;
        
    constexpr Iterator begin() { return Iterator(m_Dense, static_cast<u32>(m_Dense.size() - 1)); }
    constexpr Iterator end() { return Iterator(m_Dense, -1); }

    void Clear();
    
    constexpr St GetNullFlag() const { return NON_ELEMENT; }

    constexpr const std::vector<Dt>& GetDense() const { return m_Dense; }
private:
    constexpr std::vector<St>* GetOrCreate(u32 index);
    constexpr const std::vector<St>* TryGet(u32 index) const;
    constexpr std::vector<St>* TryGet(u32 index);
private:
    std::vector<std::unique_ptr<std::vector<St>>> m_SparsePaged;
    std::vector<Dt> m_Dense;
};

template <typename St, typename Dt>
void SparseSet<St, Dt>::Clear()
{
    m_Dense.clear();
    m_SparsePaged.clear();
}

template <typename St, typename Dt>
constexpr St SparseSet<St, Dt>::Push(Dt value)
{
    auto&& [gen, index] = Traits::Decompose(value);
    auto* sparseSet = GetOrCreate(index);
    auto mappedIndex = MathUtils::fastMod(index, SPARSE_SET_PAGE_SIZE);
    ASSERT(!Has(value), "Value is already set")
    ASSERT((*sparseSet)[mappedIndex] == NON_ELEMENT, "Catastrophic failure")
    (*sparseSet)[mappedIndex] = static_cast<St>(m_Dense.size());
    m_Dense.emplace_back(value);
    
    return (*sparseSet)[mappedIndex];
}

template <typename St, typename Dt>
template <typename PushCallback>
constexpr St SparseSet<St, Dt>::Push(Dt value, PushCallback callback)
{
    auto&& [gen, index] = Traits::Decompose(value);
    auto* sparseSet = GetOrCreate(index);
    auto mappedIndex = MathUtils::fastMod(index, SPARSE_SET_PAGE_SIZE);
    ASSERT(!Has(value), "Value is already set")
    ASSERT((*sparseSet)[mappedIndex] == NON_ELEMENT, "Catastrophic failure")
    (*sparseSet)[mappedIndex] = static_cast<St>(m_Dense.size());
    m_Dense.emplace_back(value);
    callback((*sparseSet)[mappedIndex]);
    
    return (*sparseSet)[mappedIndex];
}

template <typename St, typename Dt>
constexpr void SparseSet<St, Dt>::Pop(Dt value)
{
    auto&& [gen, index] = Traits::Decompose(value);
    auto* sparseSet = TryGet(index);
    auto mappedIndex = MathUtils::fastMod(index, SPARSE_SET_PAGE_SIZE);
    ASSERT(sparseSet, "Invalid value")
    ASSERT((*sparseSet)[mappedIndex] != NON_ELEMENT, "No such value")
    /* we keep the continuous layout, w/o need to maintain original order,
     * so instead of classic ordered remove operation,
     * we swap with the last and pop the last
     */
    if (m_Dense.size() > 1)
    {
        Dt lastVal = m_Dense.back();
        auto&& [lvGen, lvIndex] = Traits::Decompose(lastVal);
        auto* lvSparseSet = TryGet(lvIndex);
        auto mappedLvIndex = MathUtils::fastMod(lvIndex, SPARSE_SET_PAGE_SIZE);
        ASSERT((*lvSparseSet)[mappedLvIndex] != NON_ELEMENT, "Catastrophic failure")
        std::swap(m_Dense[(*sparseSet)[mappedIndex]], m_Dense.back());
        std::swap((*sparseSet)[mappedIndex], (*lvSparseSet)[mappedLvIndex]);
    }
    ASSERT(!m_Dense.empty(), "Set is empty")
    /* double delete protection */
    (*sparseSet)[mappedIndex] = NON_ELEMENT;
    m_Dense.pop_back();
}

template <typename St, typename Dt>
template <typename PopCallback, typename SwapCallback>
constexpr void SparseSet<St, Dt>::Pop(Dt value, PopCallback popCallback, SwapCallback swapCallback)
{
    auto&& [gen, index] = Traits::Decompose(value);
    auto* sparseSet = TryGet(index);
    auto mappedIndex = MathUtils::fastMod(index, SPARSE_SET_PAGE_SIZE);
    ASSERT(sparseSet, "Invalid value")
    ASSERT((*sparseSet)[mappedIndex] != NON_ELEMENT, "No such value")
    /* we keep the continuous layout, w/o need to maintain original order,
     * so instead of classic ordered remove operation,
     * we swap with the last and pop the last
     */
    if (m_Dense.size() > 1)
    {
        Dt lastVal = m_Dense.back();
        auto&& [lvGen, lvIndex] = Traits::Decompose(lastVal);
        auto* lvSparseSet = TryGet(lvIndex);
        auto mappedLvIndex = MathUtils::fastMod(lvIndex, SPARSE_SET_PAGE_SIZE);
        ASSERT((*lvSparseSet)[mappedLvIndex] != NON_ELEMENT, "Catastrophic failure")
        swapCallback((*sparseSet)[mappedIndex], static_cast<St>(m_Dense.size() - 1));
        std::swap(m_Dense[(*sparseSet)[mappedIndex]], m_Dense.back());
        std::swap((*sparseSet)[mappedIndex], (*lvSparseSet)[mappedLvIndex]);
    }
    ASSERT(!m_Dense.empty(), "Set is empty")
    popCallback();
    /* double delete protection */
    (*sparseSet)[mappedIndex] = NON_ELEMENT;
    m_Dense.pop_back();
}

template <typename St, typename Dt>
constexpr bool SparseSet<St, Dt>::Has(Dt value) const
{
    auto&& [gen, index] = Traits::Decompose(value);
    auto* sparseSet = TryGet(index);
    auto mappedIndex = MathUtils::fastMod(index, SPARSE_SET_PAGE_SIZE);
    if (sparseSet == nullptr)
        return false;
    St sparseI = (*sparseSet)[mappedIndex];
    
    return sparseI < static_cast<St>(m_Dense.size()) && m_Dense[sparseI] == value;
}

template <typename St, typename Dt>
constexpr St SparseSet<St, Dt>::GetIndexOf(Dt value) const
{
    auto&& [gen, index] = Traits::Decompose(value);
    auto* sparseSet = TryGet(index);
    ASSERT(sparseSet, "No such value")
    auto mappedIndex = MathUtils::fastMod(index, SPARSE_SET_PAGE_SIZE);
    
    return (*sparseSet)[mappedIndex];
}

template <typename St, typename Dt>
constexpr Dt& SparseSet<St, Dt>::operator[](Dt value)
{
    return const_cast<Dt&>(const_cast<const SparseSet&>(*this).operator[](value));
}

template <typename St, typename Dt>
constexpr const Dt& SparseSet<St, Dt>::operator[](Dt value) const
{
    auto&& [gen, index] = Traits::Decompose(value);
    auto* sparseSet = TryGet(index);
    auto mappedIndex = MathUtils::fastMod(index, SPARSE_SET_PAGE_SIZE);
    ASSERT(sparseSet, "Invalid index")
    
    return (*sparseSet)[mappedIndex];
}

template <typename St, typename Dt>
constexpr std::vector<St>* SparseSet<St, Dt>::GetOrCreate(u32 index)
{
    u32 pageNum = index >> SPARSE_SET_PAGE_SIZE_LOG;
    if (pageNum >= m_SparsePaged.size())
        m_SparsePaged.resize(pageNum + 1);
    if (!m_SparsePaged[pageNum])
        m_SparsePaged[pageNum] = std::make_unique<std::vector<St>>(SPARSE_SET_PAGE_SIZE, NON_ELEMENT);
    
    return m_SparsePaged[pageNum].get();
}

template <typename St, typename Dt>
constexpr const std::vector<St>* SparseSet<St, Dt>::TryGet(u32 index) const
{
    u32 pageNum = index >> SPARSE_SET_PAGE_SIZE_LOG;
    
    return pageNum < m_SparsePaged.size() ? m_SparsePaged[pageNum].get() : nullptr; 
}

template <typename St, typename Dt>
constexpr std::vector<St>* SparseSet<St, Dt>::TryGet(u32 index)
{
    return const_cast<std::vector<St>*>(const_cast<const SparseSet&>(*this).TryGet(index));
}
