#version 460

#include "globals.shader_header"

layout(local_size_x = 32, local_size_y = 32) in;

@immutable_sampler
layout(set = 0, binding = 0) uniform sampler u_sampler;
layout(set = 1, binding = 0) uniform textureCube u_env;
layout(set = 1, binding = 1, rgba16f) uniform writeonly imageCube u_prefilter;

layout(push_constant) uniform push_constants {
    vec2 u_irradiance_size_inv;
    vec2 u_env_size_inv;
    float u_roughness;
};

vec4 prefilter(vec3 normal) {
    const uint n = 1024;
    vec3 prefilter = vec3(0.0f);
    float total_weight = 0.0f;
    for (uint i = 0; i < n; i++) {
        const vec2 hammersley = hammersley2d(i, n);
        const vec3 sample_dir = importance_sample_GGX(hammersley, normal, u_roughness);
        const vec3 l = normalize(2.0f * dot(normal, sample_dir) * sample_dir - normal);
        const float n_dot_l = clamp(dot(normal, l), 0.0f, 1.0f);
        
        if (n_dot_l > 0.0f) {
            const float n_dot_h = clamp(dot(normal, sample_dir), 0.0f, 1.0f);
            const float h_dot_v = n_dot_h;
            const float d = d_GGX(n_dot_h, u_roughness);
            float pdf = d * n_dot_h / (4.0f * h_dot_v) + 1e-4;
            float sa_texel = 4.0f * PI * u_env_size_inv.x * u_env_size_inv.x / 6.0f;
            float sa_sample = 1.0f / (float(n) * pdf + 1e-4);
            
            float mip_level = u_roughness > 0.0f ? 0.5f * log2(sa_sample / sa_texel) : 0.0f;
            
            prefilter += textureLod(samplerCube(u_env, u_sampler), l, mip_level).rgb * n_dot_l;
            total_weight += n_dot_l;
        }
    }
    prefilter /= total_weight;
    
    return vec4(prefilter, 1.0f);
}

void main() {
    const vec3 normal = cubemap_normal_vector(gl_GlobalInvocationID, u_irradiance_size_inv);
    const vec4 color = prefilter(normal);

    const ivec3 coord = ivec3(gl_GlobalInvocationID);
    imageStore(u_prefilter, coord, color);
}