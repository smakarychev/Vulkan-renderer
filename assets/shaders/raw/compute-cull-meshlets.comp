#version 460

layout(local_size_x = 64) in;

#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_EXT_shader_explicit_arithmetic_types: require
#extension GL_EXT_shader_explicit_arithmetic_types_int8: require

struct VkDrawIndexedIndirectCommand {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;
};

@dynamic
layout(set = 0, binding = 0) uniform scene_data {
    mat4 view_matrix; // 4
    float frustum_top_y;
    float frustum_top_z;
    float frustum_right_x;
    float frustum_right_z; // 4
    float frustum_near;
    float frustum_far;
    float projection_width;
    float projection_height; // 4
    float depth_pyramid_width;
    float depth_pyramid_height;
    uint pad0;
    uint pad1; // 4
} u_scene_data;

layout(set = 0, binding = 1) uniform sampler2D u_depth_pyramid;

struct object_data {
    mat4 model;
    // bounding sphere
    float x;
    float y;
    float z;
    float r;
};

layout(std430, set = 0, binding = 2) readonly buffer object_buffer {
    object_data objects[];
} u_object_buffer;

@dynamic
layout(std430, set = 0, binding = 3) readonly buffer count_buffer {
    uint count;
} u_count_buffer;

struct Meshlet
{
    int8_t cone_x;
    int8_t cone_y;
    int8_t cone_z;
    int8_t cone_cutoff;
    // bounding sphere
    float x;
    float y;
    float z;
    float r;
    uint render_object;
    // these 3 values actually serve as a padding, but might also be used as a debug meshlet shading
    float R;
    float G;
    float B;
    uint is_occluded;
    uint pad0;
    uint pad1;
};

layout(std430, set = 0, binding = 4) buffer meshlet_buffer {
    Meshlet meshlets[];
} u_meshlet_buffer;

layout(std430, set = 0, binding = 5) buffer command_buffer {
    VkDrawIndexedIndirectCommand commands[];
} u_command_buffer;

float extract_scale(mat4 matrix) {
    vec3 scales = vec3(dot(matrix[0], matrix[0]), dot(matrix[1], matrix[1]), dot(matrix[2], matrix[2]));
    return max(scales.x, max(scales.y, scales.z));
}

bool is_backface_visible(vec3 sphere_origin, float radius, vec3 cone_axis, float cone_cutoff) {
    return dot(sphere_origin, cone_axis) < cone_cutoff * length(sphere_origin) + radius;
}

bool is_frustum_visible(vec3 sphere_origin, float radius) {
    bool visible = true;
    visible = visible && abs(u_scene_data.frustum_right_x * sphere_origin.x) < -sphere_origin.z * u_scene_data.frustum_right_z + radius;
    visible = visible && abs(u_scene_data.frustum_top_y * sphere_origin.y) < -sphere_origin.z * u_scene_data.frustum_top_z + radius;
    visible = visible && sphere_origin.z - radius < -u_scene_data.frustum_near && sphere_origin.z + radius > -u_scene_data.frustum_far;
    
    return visible;
}

bool is_occlusion_visible(vec3 sphere_origin, float radius) {
    if (sphere_origin.z + radius >= -u_scene_data.frustum_near)
        return true;
    
    vec4 aabb;
    vec3 cr = sphere_origin * radius;
    float czr2 = sphere_origin.z * sphere_origin.z - radius * radius;

    float vx = sqrt(sphere_origin.x * sphere_origin.x + czr2);
    float minx = (vx * sphere_origin.x - cr.z) / (vx * sphere_origin.z + cr.x);
    float maxx = (vx * sphere_origin.x + cr.z) / (vx * sphere_origin.z - cr.x);

    float vy = sqrt(sphere_origin.y * sphere_origin.y + czr2);
    float miny = (vy * sphere_origin.y - cr.z) / (vy * sphere_origin.z + cr.y);
    float maxy = (vy * sphere_origin.y + cr.z) / (vy * sphere_origin.z - cr.y);
    aabb = vec4(minx * u_scene_data.projection_width, miny * u_scene_data.projection_height, maxx * u_scene_data.projection_width, maxy * u_scene_data.projection_height);
    // clip space -> uv space
    aabb = aabb.xwzy * vec4(-0.5f, 0.5f, -0.5f, 0.5f) + vec4(0.5f);

    float width =  (aabb.x - aabb.z) * u_scene_data.depth_pyramid_width;
    float height = (aabb.y - aabb.w) * u_scene_data.depth_pyramid_height;

    float level = ceil(log2(max(width, height)));

    float depth = textureLod(u_depth_pyramid, (aabb.xy + aabb.zw) * 0.5, level).r;

    float coeff = 1.0f / (u_scene_data.frustum_far - u_scene_data.frustum_near);
    float projected_depth = coeff *
        (-u_scene_data.frustum_far * u_scene_data.frustum_near / (sphere_origin.z + radius) -
        u_scene_data.frustum_near);

    return projected_depth >= depth;
}

bool is_visible(uint id) {
    Meshlet meshlet = u_meshlet_buffer.meshlets[id];
    u_meshlet_buffer.meshlets[id].is_occluded = 0;
    object_data object = u_object_buffer.objects[meshlet.render_object];

    vec3 origin = vec3(u_scene_data.view_matrix * object.model * vec4(meshlet.x, meshlet.y, meshlet.z, 1.0f));
    float radius = meshlet.r * extract_scale(object.model);
    
    vec3 cone_axis = vec3(meshlet.cone_x, meshlet.cone_y, meshlet.cone_z) / 127.0f;
    cone_axis = vec3(u_scene_data.view_matrix * object.model * vec4(cone_axis, 0.0f));
    float cone_cutoff = float(meshlet.cone_cutoff) / 127.0f;
    
    bool visible = true;
    visible = visible && is_backface_visible(origin, radius, cone_axis, cone_cutoff);
    visible = visible && is_frustum_visible(origin, radius);
    if (visible) {
        visible = is_occlusion_visible(origin, radius);
        u_meshlet_buffer.meshlets[id].is_occluded = int(!visible);
    }
    
    return visible;
}

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id >= u_count_buffer.count)
        return;
    
    uint meshlet_id = u_command_buffer.commands[id].firstInstance;
    bool visible = is_visible(meshlet_id);
    
    u_command_buffer.commands[id].instanceCount = int(visible);
}