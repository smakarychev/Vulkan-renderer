// based on "A Scalable and Production Ready Sky and Atmosphere Rendering Technique by SÃ©bastien Hillaire (Epic Games, Inc)"
// https://github.com/sebh/UnrealEngineSkyAtmosphere

#version 460

#include "common.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

@immutable_sampler_clamp_edge
layout(set = 0, binding = 0) uniform sampler u_sampler;
layout(set = 1, binding = 0) uniform texture2D u_transmittance_lut;
layout(set = 1, binding = 1, rgba16f) uniform writeonly image2D u_sky_view_lut;

layout(scalar, set = 1, binding = 2) uniform atmosphere_settings {
    AtmosphereSettings settings;
} u_atmosphere_settings;

layout(scalar, set = 1, binding = 3) uniform directional_light {
    DirectionalLight light;
} u_directional_light;

layout(set = 1, binding = 4) uniform camera_buffer {
    CameraGPU camera;
} u_camera;

float get_visibility(AtmosphereSettings atmosphere, vec3 ro, vec3 rd) {
    const float surface = intersect_sphere(ro, rd, vec3(0.0f), atmosphere.surface).t;
    const Intersection atmosphere_intersection = intersect_sphere(ro, rd, vec3(0.0f), atmosphere.atmosphere);

    return (surface == NO_HIT || atmosphere_intersection.t + atmosphere_intersection.depth < surface) ? 1.0f : 0.0f;
}

vec3 sky_view(AtmosphereSettings atmosphere, vec3 ro, vec3 rd, vec3 sun_dir, float depth) {
    vec3 luminance = vec3(0.0f);
    vec3 optical_depth = vec3(0.0f);
    vec3 throughput = vec3(1.0f);
    
    const float cos_theta = dot(rd, sun_dir);
    const float rayleigh = rayleigh_phase(cos_theta);
    const float mie = mie_phase(cos_theta);
    const float sample_t = 0.3f;
    
    float t = 0.0f;
    
    for (float i = 0.0f; i < SKY_STEPS; i += 1.0f) {
        const float new_t = depth * (i + sample_t) / SKY_STEPS;
        const float dt = new_t - t;
        t = new_t;
        const vec3 x = ro + rd * t;
        const MediaSample media = sample_media(x, vec3(0.0f), atmosphere);
        
        const vec3 sample_optical_depth = media.extinction * dt;
        const vec3 sample_transmittance = exp(-sample_optical_depth);
        optical_depth += sample_optical_depth;
        
        const float r = length(x);
        const vec3 up = x / r;
        const float mu = dot(sun_dir, up);
        const vec2 transmittance_uv = transmittance_uv_from_r_mu(atmosphere, r, mu);
        const vec3 transmittance = textureLod(sampler2D(u_transmittance_lut, u_sampler), transmittance_uv, 0).rgb;
        const vec3 phase_scattering = media.rayleigh * rayleigh + media.mie * mie;
        
        const vec3 S = get_visibility(atmosphere, x, sun_dir) * phase_scattering * transmittance;
        const vec3 S_integral = (S - S * sample_transmittance) / media.extinction;
        luminance += throughput * S_integral;
        
        throughput *= sample_transmittance;
    }
    
    // todo: bounced-off ground light
    
    return luminance;
}

void main() {
    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    if (coord.x >= SKY_VIEW_LUT_WIDTH || coord.y >= SKY_VIEW_LUT_HEIGHT) 
        return;
    
    const vec2 uv = vec2(coord) / vec2(SKY_VIEW_LUT_WIDTH, SKY_VIEW_LUT_HEIGHT);
    
    const AtmosphereSettings atm = u_atmosphere_settings.settings;
    
    const vec3 pos = u_camera.camera.position * 1e-4f + vec3(0.0f, atm.surface, 0.0f);
    const float r = length(pos);
    
    const vec2 zenith_view_cos = sky_view_zen_view_cos_from_uv(atm, uv, r);
    const vec3 up = pos / r;
    const float mu = dot(u_directional_light.light.direction, up);
    const vec3 sun_dir = normalize(vec3(sqrt(1.0f - mu * mu), mu, 0.0f));
    
    const vec3 ro = vec3(0.0f, r, 0.0f);
    const float zenith_sin = sqrt(1.0f - zenith_view_cos.x * zenith_view_cos.x);
    const vec3 rd = vec3(
        zenith_sin * zenith_view_cos.y,
        zenith_view_cos.x,
        zenith_sin * sqrt(1.0f - zenith_view_cos.y * zenith_view_cos.y));

    const Intersection atmosphere_intersection = intersect_sphere(ro, rd, vec3(0.0f), atm.atmosphere);
    if (atmosphere_intersection.depth == NO_HIT) {
        imageStore(u_sky_view_lut, coord, vec4(vec3(0.0f), 1.0f));
        return;
    }

    const Intersection surface_intersection = intersect_sphere(ro, rd, vec3(0.0f), atm.surface);
    const float depth = min(
        atmosphere_intersection.depth,
        surface_intersection.t - atmosphere_intersection.t);
    
    const vec3 color = sky_view(atm, ro + rd * atmosphere_intersection.t, rd, sun_dir, depth);
    
    imageStore(u_sky_view_lut, coord, vec4(color, 1.0f));
}
