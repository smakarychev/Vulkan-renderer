#version 460

#include "common.glsl"
#include "../common.glsl"
#include "../../view_info.glsl"
#include "../../utility.glsl"
#include "../atmosphere/atmosphere-functions.glsl"

layout(local_size_x = 8, local_size_y = 8) in;

#extension GL_EXT_samplerless_texture_functions: require
#extension GL_EXT_scalar_block_layout: require 
#extension GL_EXT_control_flow_attributes: require 
#extension GL_EXT_nonuniform_qualifier: require 

@immutable_sampler_clamp_edge
layout(set = 0, binding = 0) uniform sampler u_sampler;

@immutable_sampler_nearest_clamp_edge
layout(set = 0, binding = 1) uniform sampler u_sampler_nearest;

layout(set = 1, binding = 0) uniform texture2D u_cloud_color;
layout(set = 1, binding = 1) uniform texture2D u_cloud_depth;
layout(set = 1, binding = 2) uniform texture2D u_cloud_color_accumulation_in;
layout(set = 1, binding = 3) uniform texture2D u_cloud_depth_accumulation_in;
layout(set = 1, binding = 4) uniform texture2D u_cloud_reprojection_factor_in;
layout(set = 1, binding = 5, rgba16f) uniform writeonly image2D u_cloud_color_accumulation_out;
layout(set = 1, binding = 6, rg16f) uniform writeonly image2D u_cloud_depth_accumulation_out;
layout(set = 1, binding = 7, r8) uniform writeonly image2D u_cloud_reprojection_factor_out;

layout(scalar, set = 1, binding = 8) uniform view_info {
    ViewInfo view;
} u_view_info;

layout(push_constant, scalar) uniform push_constants {
    float u_wind_angle;
    float u_wind_speed;
    float u_wind_upright_amount;
    float u_wind_horizontal_skew;
};

const float VIEW_HEIGHT = DEFAULT_VIEW_HEIGHT_M;

const vec2 reprojection_factors = vec2(0.6f, 0.85f);
ivec2 image_size = imageSize(u_cloud_color_accumulation_out);
vec2 image_size_inv = 1.0f / image_size;
vec3 wind_direction = vec3(cos(u_wind_angle), -u_wind_upright_amount, sin(u_wind_angle));

float get_reprojection_factor(float prev, float new) {
    return mix(prev, new, 1.0f - exp(-0.07f));
}

vec4 variance_clamp_color(ivec2 render_coord, vec4 color) {
    vec4 m1 = vec4(0.0f);
    vec4 m2 = vec4(0.0f);
    for (int x = -1; x <= 1; x++)
    {
        for (int y = -1; y <= 1; y++)
        {
            const ivec2 offset = ivec2(x, y);
            ivec2 neighbor = render_coord + offset;
            neighbor = clamp(neighbor, ivec2(0), image_size / REPROJECTION_RES - 1);
            const vec4 neightbor_color = texelFetch(sampler2D(u_cloud_color, u_sampler_nearest), neighbor, 0);
            m1 += neightbor_color;
            m2 += neightbor_color * neightbor_color;
        }
    }

    const vec4 mean = m1 / 9.0;
    const vec4 variance = (m2 / 9.0) - (mean * mean);
    const vec4 stddev = sqrt(max(variance, 0.0f));
    
    return clamp(color,  mean - stddev, mean + stddev);
}

void main() {
    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 render_coord = coord / REPROJECTION_RES;
    
    const ivec2 drawn_pixel_coord = 
        (coord / REPROJECTION_RES) * REPROJECTION_RES + 
        REPROJECTION_OFFSETS[u_view_info.view.frame_number_u32 % REPROJECTION_RES_2D];
    const bool is_drawn_pixel = coord == drawn_pixel_coord;
    
    const vec2 uv = (vec2(coord) + 0.5f) * image_size_inv;
    
    const vec4 color = textureLod(sampler2D(u_cloud_color, u_sampler_nearest), uv, 0);
    const vec4 depth = textureLod(sampler2D(u_cloud_depth, u_sampler_nearest), uv, 0);
    
    const vec4 clip = vec4(uv * 2 - 1, project_reverse_z(-depth.y, u_view_info.view.near, u_view_info.view.far), 1);
    vec4 unprojected = u_view_info.view.inv_projection * clip;
    unprojected /= unprojected.w;
    unprojected.xyz = mat3(u_view_info.view.inv_view) * unprojected.xyz;

    //unprojected.xyz += layer.relative_height * wind_direction * u_wind_horizontal_skew;
    // todo: use delta time here and in main shader
    // todo: it does not seem to work for some reason...
    unprojected.xyz -= wind_direction * u_wind_speed;
    
    unprojected.xyz = mat3(u_view_info.view.prev_view) * unprojected.xyz;
    vec4 reprojected = u_view_info.view.prev_projection * unprojected;
    reprojected /= reprojected.w;

    const vec2 prev_uv = reprojected.xy * 0.5f + 0.5f;

    const vec4 prev_color = textureLod(sampler2D(u_cloud_color_accumulation_in, u_sampler), prev_uv, 0);
    const vec4 prev_depth = textureLod(sampler2D(u_cloud_depth_accumulation_in, u_sampler), prev_uv, 0);
    const float prev_reprojection_factor = textureLod(sampler2D(u_cloud_reprojection_factor_in, u_sampler), prev_uv, 0).x;

    if (coord.x >= image_size.x || coord.y >= image_size.y) {
        return;
    }
    
    if (u_view_info.view.frame_number_u32 < 2 ||
        prev_uv.x < 0.0f || prev_uv.x > 1.0f || prev_uv.y < 0.0f || prev_uv.y > 1.0f) {

        const vec4 color = textureLod(sampler2D(u_cloud_color, u_sampler), uv, 0);
        const vec4 depth = textureLod(sampler2D(u_cloud_depth, u_sampler), uv, 0);
        
        imageStore(u_cloud_color_accumulation_out, coord, color);
        imageStore(u_cloud_depth_accumulation_out, coord, depth);
        imageStore(u_cloud_reprojection_factor_out, coord, vec4(0.05f, 0.0f, 0.0f, 0.0f));
        
        return;
    }
    
    vec4 out_color = prev_color;
    vec4 out_depth = prev_depth;
    float out_reprojection_factor = prev_reprojection_factor;

    if (is_drawn_pixel) {
        if (abs(depth.g - prev_depth.g) > depth.g * 0.1f) {
            out_color = color;
            out_depth = depth;
            out_reprojection_factor = reprojection_factors.x;
        }
        else {
            out_color = variance_clamp_color(render_coord, out_color);    
            out_color = mix(color, out_color, prev_reprojection_factor);
            out_depth = depth;
            out_reprojection_factor = get_reprojection_factor(prev_reprojection_factor, reprojection_factors.y);
        }
    } else {
        if (abs(depth.g - prev_depth.g) > depth.g * 0.1f) {
            float closest_depth = DEPTH_MAX;
            for (int y = -1; y <= 1; y++) {
                for (int x = -1; x <= 1; x++) {
                    if (x == 0 && y == 0)
                        continue;

                    const ivec2 offset = ivec2(x, y);
                    ivec2 neighbor = render_coord + offset;
                    neighbor = clamp(neighbor, ivec2(0), image_size / REPROJECTION_RES - 1);

                    const vec4 neighbor_depth = texelFetch(sampler2D(u_cloud_depth, u_sampler_nearest), neighbor, 0);
                    if (neighbor_depth.x > closest_depth) {
                        closest_depth = neighbor_depth.x;
                        out_color = texelFetch(sampler2D(u_cloud_color, u_sampler_nearest), neighbor, 0);
                        out_depth = neighbor_depth;
                    }
                }
            }
            
            out_reprojection_factor = get_reprojection_factor(prev_reprojection_factor, reprojection_factors.x);
        } 
        else {
            out_reprojection_factor = get_reprojection_factor(prev_reprojection_factor, reprojection_factors.y);
        }
    }

    imageStore(u_cloud_color_accumulation_out, coord, out_color);
    imageStore(u_cloud_depth_accumulation_out, coord, out_depth);
    imageStore(u_cloud_reprojection_factor_out, coord, vec4(out_reprojection_factor, 0.0f, 0.0f, 0.0f));
}