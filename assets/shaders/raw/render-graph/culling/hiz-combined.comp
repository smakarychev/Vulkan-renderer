#version 460

#ifndef HIZ_BLIT
#define HIZ_BLIT 0
#endif // HIZ_BLIT

#ifndef HIZ_GENERATE
#define HIZ_GENERATE 1
#endif // HIZ_GENERATE

#ifndef HIZ_MIN_MAX
#define HIZ_MIN_MAX 1
#endif // HIZ_MIN_MAX

#ifndef HIZ_MIN_MAX_DEPTH_BUFFER
#define HIZ_MIN_MAX_DEPTH_BUFFER 1
#endif // HIZ_MIN_MAX_DEPTH_BUFFER

#extension GL_KHR_shader_subgroup_ballot: enable
#extension GL_KHR_shader_subgroup_shuffle: enable
#extension GL_KHR_shader_subgroup_arithmetic: enable

layout(set = 0, binding = 0) uniform sampler u_min_sampler;

#if HIZ_MIN_MAX
layout(set = 0, binding = 1) uniform sampler u_max_sampler;
#endif // HIZ_MIN_MAX

layout(set = 1, binding = 0) uniform texture2D u_input;

#if HIZ_MIN_MAX
layout(set = 1, binding = 1, rg16f) uniform writeonly image2D u_output[16];
#if HIZ_MIN_MAX_DEPTH_BUFFER
layout(set = 1, binding = 2) buffer min_max {
    uint min;
    uint max;
} u_min_max;
#endif // HIZ_MIN_MAX_DEPTH_BUFFER
#else // HIZ_MIN_MAX
layout(set = 1, binding = 1, r16f) uniform writeonly image2D u_output[16];
#endif // HIZ_MIN_MAX

ivec2 levelSize(int level) { return imageSize(u_output[level]); }
#define NVPRO_PYRAMID_LEVEL_SIZE levelSize

#if HIZ_MIN_MAX
#define NVPRO_PYRAMID_TYPE vec2
void store(in ivec2 coord, in int level, in vec2 in_) {
    imageStore(u_output[level], coord, vec4(in_.xy, 0, 0));
}
vec2 reduce4(vec2 v00, vec2 v01, vec2 v10, vec2 v11) {
    vec2 reduced;
    reduced.x = min(min(v00.x, v01.x), min(v10.x, v11.x));
    reduced.y = max(max(v00.y, v01.y), max(v10.y, v11.y));

    return reduced;
}
void loadReduce4(in ivec2 coord, in int level, out vec2 out_) {
    vec2 normalized_coord = (vec2(coord) + vec2(1)) / levelSize(level);
    out_.x = textureLod(sampler2D(u_input, u_min_sampler), normalized_coord, level).r;
    out_.y = textureLod(sampler2D(u_input, u_max_sampler), normalized_coord, level).g;
}
#else // HIZ_MIN_MAX
#define NVPRO_PYRAMID_TYPE float
void store(in ivec2 coord, in int level, in float in_) {
    imageStore(u_output[level], coord, vec4(in_, 0, 0, 0));
}
float reduce4(float v00, float v01, float v10, float v11) {
    return min(min(v00, v01), min(v10, v11));
}
void loadReduce4(in ivec2 coord, in int level, out float out_) {
    vec2 normalized_coord = (vec2(coord) + vec2(1)) / levelSize(level);
    out_ = textureLod(sampler2D(u_input, u_min_sampler), normalized_coord, level).r;
}
#endif // HIZ_MIN_MAX

#define NVPRO_PYRAMID_STORE(coord, level, in_) store(coord, level, in_)

#define NVPRO_PYRAMID_REDUCE4(v00, v01, v10, v11, out_) \
    out_ = reduce4(v00, v01, v10, v11)

#define NVPRO_PYRAMID_LOAD_REDUCE4 loadReduce4

#if HIZ_BLIT
layout(local_size_x = 8, local_size_y = 8) in;

void blit_pass() {
    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    const vec2 image_size_inverse = 1.0f / levelSize(0);
    const vec2 uv = vec2(coord + 0.5f) * image_size_inverse;
    
    vec2 depth_sample;
    depth_sample.r = textureLod(sampler2D(u_input, u_min_sampler), uv, 0).r;
    #if HIZ_MIN_MAX
    depth_sample.g = textureLod(sampler2D(u_input, u_max_sampler), uv, 0).r;
    
    #if HIZ_MIN_MAX_DEPTH_BUFFER
    
    if (depth_sample.r != 0) {
        const float min = subgroupMin(depth_sample.r);
        const float max = subgroupMax(depth_sample.g);
        
        if (subgroupElect()) {
            atomicMin(u_min_max.min, floatBitsToUint(min));
            atomicMax(u_min_max.max, floatBitsToUint(max));
        }
    }
    #endif // HIZ_MIN_MAX_DEPTH_BUFFER
    
    #endif // HIZ_MIN_MAX
    
    imageStore(u_output[0], coord, vec4(depth_sample.rg, 0, 0));
}

void main() {
    blit_pass();
}
#elif HIZ_GENERATE
#define NVPRO_PYRAMID_IS_FAST_PIPELINE 1
#include "../../../nvpro/nvpro_pyramid.glsl"
void main() {
    nvproPyramidMain();
}
#endif // HIZ_BLIT

