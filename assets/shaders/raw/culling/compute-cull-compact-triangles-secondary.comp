#version 460

#extension GL_KHR_shader_subgroup_ballot: enable
#extension GL_KHR_shader_subgroup_vote: enable

layout(local_size_x = 256) in;

struct VkDrawIndexedIndirectCommand {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;
};

struct Position {
    float x;
    float y;
    float z;
};

struct object_data {
    mat4 model;
    // bounding sphere
    float x;
    float y;
    float z;
    float r;
};

struct Meshlet
{
    uint _unused_0;
    float _unused_x;
    float _unused_y;
    float _unused_z;
    float _unused_r;

    uint object_id;

    float _unused_R;
    float _unused_G;
    float _unused_B;

    uint _unused_1;

    uint pad0;
    uint pad1;
};

struct Triangle {
    vec4 a;
    vec4 b;
    vec4 c;
};

@dynamic
layout(set = 0, binding = 0) uniform scene_data {
    mat4 projection_matrix; // 4
    mat4 view_matrix; // 4
    float frustum_top_y;
    float frustum_top_z;
    float frustum_right_x;
    float frustum_right_z; // 4
    float frustum_near;
    float frustum_far;
    float projection_width;
    float projection_height; // 4
    float depth_pyramid_width;
    float depth_pyramid_height;
    uint mesh_count;
    uint pad0; // 4
} u_scene_data;

layout(set = 0, binding = 1) uniform sampler2D u_depth_pyramid;

layout(std430, set = 0, binding = 2) buffer final_command_buffer {
    VkDrawIndexedIndirectCommand commands[];
} u_final_command_buffer;

@dynamic
layout(std430, set = 0, binding = 3) buffer command_count_buffer {
    uint count;
} u_command_count_buffer;

layout(std430, set = 0, binding = 4) readonly buffer meshlet_buffer {
    Meshlet meshlets[];
} u_meshlet_buffer;

layout(std430, set = 0, binding = 5) readonly buffer object_buffer {
    object_data objects[];
} u_object_buffer;

layout(std430, set = 0, binding = 6) readonly buffer positions_buffer {
    Position positions[];
} u_positions_buffer;

layout(std430, set = 0, binding = 7) buffer culled_indices_buffer {
    uint indices[];
} u_culled_indices_buffer;

layout(std430, set = 0, binding = 8) buffer occluded_triangle_count_buffer {
    uint counts[];
} u_occluded_triangle_count_buffer;

vec4 vec4FromPosition(Position position) {
    return vec4(position.x, position.y, position.z, 1.0f);
}

bool is_occlusion_visible(float minx, float miny, float maxx, float maxy, float z) {
    vec4 aabb = vec4(minx, miny, maxx, maxy);
    // clip space -> uv space
    aabb = aabb.xyzw * 0.5f + vec4(0.5f);

    float width = (aabb.z - aabb.x) * u_scene_data.depth_pyramid_width;
    float height = (aabb.y - aabb.w) * u_scene_data.depth_pyramid_height;
    float level = ceil(log2(max(width, height)));

    float depth = textureLod(u_depth_pyramid, (aabb.xy + aabb.zw) * 0.5, level).r;

    return depth <= z;
}

void compact_visible(uint command_index, uvec3 indices, bool visible) {
    VkDrawIndexedIndirectCommand command = u_final_command_buffer.commands[command_index];

    uvec4 visible_ballot = subgroupBallot(visible);
    uint total_visible_count = subgroupBallotBitCount(visible_ballot) * 3;

    uint compacted_index_offset = 0;
    if (subgroupElect()) 
        compacted_index_offset = atomicAdd(u_final_command_buffer.commands[command_index].indexCount, total_visible_count);
    
    compacted_index_offset = subgroupBroadcastFirst(compacted_index_offset);

    if (visible) {
        uint compacted_buffer_offset = compacted_index_offset + subgroupBallotExclusiveBitCount(visible_ballot) * 3;
        uint compacted_buffer_index = u_final_command_buffer.commands[command_index].firstIndex + compacted_buffer_offset;
        u_culled_indices_buffer.indices[compacted_buffer_index + 0] = indices.x;
        u_culled_indices_buffer.indices[compacted_buffer_index + 1] = indices.y;
        u_culled_indices_buffer.indices[compacted_buffer_index + 2] = indices.z;
    }
}

void main() {
    uint command_index = gl_GlobalInvocationID.x / gl_WorkGroupSize.x;
    if (command_index >= u_command_count_buffer.count)
        return;

    VkDrawIndexedIndirectCommand command = u_final_command_buffer.commands[command_index];

    uint triangle_index = gl_LocalInvocationID.x;

    uint index_offset = triangle_index * 3;

    bool is_in_bounds = u_occluded_triangle_count_buffer.counts[command_index] > index_offset;
    if (!is_in_bounds)
        return;

    Meshlet meshlet = u_meshlet_buffer.meshlets[command.firstInstance];
    object_data object = u_object_buffer.objects[meshlet.object_id];

    uint command_first_index = command.firstIndex + gl_WorkGroupSize.x * 3;
    uvec3 indices = uvec3(
        u_culled_indices_buffer.indices[command_first_index - index_offset - 3 + 0],
        u_culled_indices_buffer.indices[command_first_index - index_offset - 3 + 1],
        u_culled_indices_buffer.indices[command_first_index - index_offset - 3 + 2]);
    
    Triangle triangle;
    triangle.a = vec4FromPosition(u_positions_buffer.positions[command.vertexOffset + indices.x]);
    triangle.b = vec4FromPosition(u_positions_buffer.positions[command.vertexOffset + indices.y]);
    triangle.c = vec4FromPosition(u_positions_buffer.positions[command.vertexOffset + indices.z]);

    mat4 transform = u_scene_data.projection_matrix * u_scene_data.view_matrix * object.model;
    triangle.a = transform * triangle.a;
    triangle.b = transform * triangle.b;
    triangle.c = transform * triangle.c;

    triangle.a.xyz /= triangle.a.w;
    triangle.b.xyz /= triangle.b.w;
    triangle.c.xyz /= triangle.c.w;

    float minx = min(triangle.a.x, min(triangle.b.x, triangle.c.x));
    float maxx = max(triangle.a.x, max(triangle.b.x, triangle.c.x));
    float miny = min(triangle.a.y, min(triangle.b.y, triangle.c.y));
    float maxy = max(triangle.a.y, max(triangle.b.y, triangle.c.y));

    float maxz = max(triangle.a.z, max(triangle.b.z, triangle.c.z));
    float depth = maxz;
    bool visible = is_occlusion_visible(minx, maxy, maxx, miny, depth);

    compact_visible(command_index, indices, visible);
}