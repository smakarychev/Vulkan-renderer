#version 460

#extension GL_KHR_shader_subgroup_ballot: enable

layout(local_size_x = 64) in;

struct VkDrawIndexedIndirectCommand {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;
};

layout(std430, set = 0, binding = 0) buffer readonly command_buffer {
    VkDrawIndexedIndirectCommand commands[];
} u_command_buffer;

layout(std430, set = 0, binding = 1) buffer writeonly compacted_command_buffer {
    VkDrawIndexedIndirectCommand commands[];
} u_compacted_command_buffer;

@dynamic
layout(std430, set = 0, binding = 2) readonly buffer count_buffer {
    uint count;
} u_count_buffer;

@dynamic
layout(std430, set = 0, binding = 3) buffer visible_buffer {
    uint count;
} u_visible_buffer;

void write_compacted_visible(uint id) {
    VkDrawIndexedIndirectCommand command = u_command_buffer.commands[id];

    bool is_visible = command.instanceCount > 0;
    uvec4 is_visible_ballot = subgroupBallot(is_visible);

    // find subgroup total visible meshes count
    uint total_visible_count = subgroupBallotBitCount(is_visible_ballot);

    uint compacted_buffer_index_base;
    if (subgroupElect())
        compacted_buffer_index_base = atomicAdd(u_visible_buffer.count, total_visible_count);
    compacted_buffer_index_base = subgroupBroadcastFirst(compacted_buffer_index_base);

    uint compacted_buffer_offset = subgroupBallotExclusiveBitCount(is_visible_ballot);

    uint compacted_buffer_index = compacted_buffer_index_base + compacted_buffer_offset;

    if (is_visible)
        u_compacted_command_buffer.commands[compacted_buffer_index] = command;
}

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id >= u_count_buffer.count)
        return;

    write_compacted_visible(id);
}