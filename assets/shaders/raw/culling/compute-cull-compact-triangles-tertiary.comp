#version 460

#extension GL_KHR_shader_subgroup_ballot: enable
#extension GL_KHR_shader_subgroup_vote: enable

layout(local_size_x = 64) in;

const uint TRIANGLES_PER_MESHLET = 256;
const uint TRIANGLES_PER_WORK_GROUP = TRIANGLES_PER_MESHLET / gl_WorkGroupSize.x;

struct VkDrawIndexedIndirectCommand {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;
};

struct Position {
    float x;
    float y;
    float z;
};

struct object_data {
    mat4 model;
    // bounding sphere
    float x;
    float y;
    float z;
    float r;
};

struct Meshlet
{
    uint _unused_0;
    float _unused_x;
    float _unused_y;
    float _unused_z;
    float _unused_r;

    uint object_id;

    float _unused_R;
    float _unused_G;
    float _unused_B;

    uint _unused_1;

    uint pad0;
    uint pad1;
};

struct Triangle {
    vec4 a;
    vec4 b;
    vec4 c;
};

@dynamic
layout(set = 0, binding = 0) uniform scene_data {
    mat4 view_projection_matrix; // 4
    float frustum_top_y;
    float frustum_top_z;
    float frustum_right_x;
    float frustum_right_z; // 4
    float frustum_near;
    float frustum_far;
    float projection_width;
    float projection_height; // 4
    float depth_pyramid_width;
    float depth_pyramid_height;
    uint mesh_count;
    uint pad0; // 4
} u_scene_data;

layout(set = 0, binding = 1) uniform sampler2D u_depth_pyramid;

layout(std430, set = 0, binding = 2) buffer command_buffer {
    VkDrawIndexedIndirectCommand commands[];
} u_command_buffer;

layout(std430, set = 0, binding = 3) buffer final_command_buffer {
    VkDrawIndexedIndirectCommand commands[];
} u_final_command_buffer;

@dynamic
layout(std430, set = 0, binding = 4) buffer command_count_buffer {
    uint count;
} u_command_count_buffer;

@dynamic
layout(std430, set = 0, binding = 5) readonly buffer final_commands_offset_buffer {
    uint offset;
} u_final_commands_offset_buffer;

layout(std430, set = 0, binding = 6) readonly buffer meshlet_buffer {
    Meshlet meshlets[];
} u_meshlet_buffer;

layout(std430, set = 0, binding = 7) readonly buffer object_buffer {
    object_data objects[];
} u_object_buffer;

layout(std430, set = 0, binding = 8) readonly buffer positions_buffer {
    Position positions[];
} u_positions_buffer;

layout(std430, set = 0, binding = 9) readonly buffer indices_buffer {
    uint indices[];
} u_indices_buffer;

layout(std430, set = 0, binding = 10) buffer culled_indices_buffer {
    uint indices[];
} u_culled_indices_buffer;

layout(push_constant) uniform push_constants {
    uint u_screen_width;
    uint u_screen_height;
};

vec4 vec4FromPosition(Position position) {
    return vec4(position.x, position.y, position.z, 1.0f);
}

bool is_backface_visible(Triangle triangle) {
    return determinant(mat3(triangle.a.xyw, triangle.b.xyw, triangle.c.xyw)) <= 0;
}

bool is_screen_size_visible(vec4 aabb, float width, float height) {
    aabb = aabb * vec4(width, height, width, height);
    return round(aabb.x) != round(aabb.z) && round(aabb.y) != round(aabb.w);
}

bool is_frustum_visible(vec4 aabb) {
    return aabb.z >= 0 && aabb.x <= 1 && aabb.y >= 0 && aabb.w <= 1;
}

bool is_occlusion_visible(vec4 aabb, float z) {

    float width = (aabb.z - aabb.x) * u_scene_data.depth_pyramid_width;
    float height = (aabb.y - aabb.w) * u_scene_data.depth_pyramid_height;
    float level = ceil(log2(max(width, height)));

    float depth = textureLod(u_depth_pyramid, (aabb.xy + aabb.zw) * 0.5, level).r;

    return depth <= z;
}

void compact_visible(uint command_index, uint index_offset, bool visible) {
    VkDrawIndexedIndirectCommand command = u_command_buffer.commands[command_index];
    command_index += u_final_commands_offset_buffer.offset;
    
    uvec4 visible_ballot = subgroupBallot(visible);
    uint total_visible_count = subgroupBallotBitCount(visible_ballot) * 3;

    uint compacted_index_offset = 0;
    if (subgroupElect()) {
        u_final_command_buffer.commands[command_index].firstInstance = command.firstInstance;
        u_final_command_buffer.commands[command_index].instanceCount = command.instanceCount;
        u_final_command_buffer.commands[command_index].vertexOffset = command.vertexOffset;

        compacted_index_offset = atomicAdd(u_final_command_buffer.commands[command_index].indexCount, total_visible_count);
        u_final_command_buffer.commands[command_index].firstIndex = command_index * TRIANGLES_PER_MESHLET * 3;
    }
    compacted_index_offset = subgroupBroadcastFirst(compacted_index_offset);

    if (visible) {
        uint compacted_buffer_offset = compacted_index_offset + subgroupBallotExclusiveBitCount(visible_ballot) * 3;
        uint compacted_buffer_index = u_final_command_buffer.commands[command_index].firstIndex + compacted_buffer_offset;
        u_culled_indices_buffer.indices[compacted_buffer_index + 0] = u_indices_buffer.indices[command.firstIndex + index_offset + 0];
        u_culled_indices_buffer.indices[compacted_buffer_index + 1] = u_indices_buffer.indices[command.firstIndex + index_offset + 1];
        u_culled_indices_buffer.indices[compacted_buffer_index + 2] = u_indices_buffer.indices[command.firstIndex + index_offset + 2];
    }
}

void main() {
    uint command_index = gl_GlobalInvocationID.x / TRIANGLES_PER_MESHLET;
    if (command_index >= u_command_count_buffer.count)
        return;

    VkDrawIndexedIndirectCommand command = u_command_buffer.commands[command_index];

    uint triangle_index = gl_LocalInvocationID.x + gl_WorkGroupSize.x * ((gl_GlobalInvocationID.x / gl_WorkGroupSize.x) % TRIANGLES_PER_WORK_GROUP);

    uint index_offset = triangle_index * 3;

    bool is_in_bounds = command.indexCount > index_offset;

    if (!is_in_bounds)
        return;

    Meshlet meshlet = u_meshlet_buffer.meshlets[command.firstInstance];
    object_data object = u_object_buffer.objects[meshlet.object_id];

    Triangle triangle;
    triangle.a = vec4FromPosition(u_positions_buffer.positions[command.vertexOffset + u_indices_buffer.indices[command.firstIndex + index_offset + 0]]);
    triangle.b = vec4FromPosition(u_positions_buffer.positions[command.vertexOffset + u_indices_buffer.indices[command.firstIndex + index_offset + 1]]);
    triangle.c = vec4FromPosition(u_positions_buffer.positions[command.vertexOffset + u_indices_buffer.indices[command.firstIndex + index_offset + 2]]);

    triangle.a = u_scene_data.view_projection_matrix * object.model * triangle.a;
    triangle.b = u_scene_data.view_projection_matrix * object.model * triangle.b;
    triangle.c = u_scene_data.view_projection_matrix * object.model * triangle.c;

    bool visible = is_backface_visible(triangle);

    if (!visible)
        return;

    triangle.a.xyz /= triangle.a.w;
    triangle.b.xyz /= triangle.b.w;
    triangle.c.xyz /= triangle.c.w;

    float minx = min(triangle.a.x, min(triangle.b.x, triangle.c.x));
    float maxx = max(triangle.a.x, max(triangle.b.x, triangle.c.x));
    float miny = min(triangle.a.y, min(triangle.b.y, triangle.c.y));
    float maxy = max(triangle.a.y, max(triangle.b.y, triangle.c.y));

    vec4 aabb = vec4(minx, maxy, maxx, miny);
    aabb = aabb.xyzw * 0.5f + vec4(0.5f);
    
    float maxz = max(triangle.a.z, max(triangle.b.z, triangle.c.z));
    float depth = maxz;
    visible = is_occlusion_visible(aabb, depth);
    if (!visible)
        return;

    visible = is_screen_size_visible(aabb, u_screen_width, u_screen_height);
    if (!visible)
        return;

    visible = is_frustum_visible(aabb);

    compact_visible(command_index, index_offset, visible);
}