#version 460

#extension GL_KHR_shader_subgroup_ballot: enable
#extension GL_KHR_shader_subgroup_vote: enable

layout(local_size_x = 64) in;

struct IndirectCommand {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;

    uint render_object;
};

layout(std430, set = 0, binding = 0) readonly buffer command_buffer {
    IndirectCommand commands[];
} u_command_buffer;

@dynamic
layout(std430, set = 0, binding = 1) writeonly buffer compacted_command_buffer {
    IndirectCommand commands[];
} u_compacted_command_buffer;

layout(std430, set = 0, binding = 2) writeonly buffer compacted_command_count_buffer {
    uint count;
} u_compacted_command_count_buffer;

layout(push_constant) uniform push_constants {
    uint u_count;
};

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id >= u_count)
        return;

    IndirectCommand command = u_command_buffer.commands[id];
    
    bool should_draw = command.indexCount > 0;
    if (!subgroupAny(should_draw))
        return;
    
    uvec4 should_draw_ballot = subgroupBallot(should_draw);
    uint total_should_draw_count = subgroupBallotBitCount(should_draw_ballot);

    uint compacted_buffer_index_base = 0;
    if (subgroupElect())
        compacted_buffer_index_base = atomicAdd(u_compacted_command_count_buffer.count, total_should_draw_count);

    compacted_buffer_index_base = subgroupBroadcastFirst(compacted_buffer_index_base);

    uint compacted_buffer_offset = subgroupBallotExclusiveBitCount(should_draw_ballot);

    uint compacted_buffer_index = compacted_buffer_index_base + compacted_buffer_offset;

    if (should_draw)
        u_compacted_command_buffer.commands[compacted_buffer_index] = command;
}