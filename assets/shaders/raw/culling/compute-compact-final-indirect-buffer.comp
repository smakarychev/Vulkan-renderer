#version 460

#extension GL_KHR_shader_subgroup_ballot: enable
#extension GL_KHR_shader_subgroup_vote: enable

layout(local_size_x = 64) in;


struct IndirectCommand {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;

    uint render_object;
};

layout(std430, set = 0, binding = 0) readonly buffer final_command_buffer {
    IndirectCommand commands[];
} u_final_command_buffer;

layout(std430, set = 0, binding = 1) writeonly buffer final_command_compact_buffer {
    IndirectCommand commands[];
} u_final_command_compact_buffer;

@dynamic
layout(std430, set = 0, binding = 2) readonly buffer final_command_count_buffer {
    uint count;
} u_final_command_count_buffer;

@dynamic
layout(std430, set = 0, binding = 3) writeonly buffer final_compact_command_count_buffer {
    uint count;
} u_final_compact_command_count_buffer;

@dynamic
layout(std430, set = 0, binding = 4) readonly buffer final_commands_offset_buffer {
    uint offset;
} u_final_commands_offset_buffer;

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id >= u_final_command_count_buffer.count)
        return;

    IndirectCommand command = u_final_command_buffer.commands[id + u_final_commands_offset_buffer.offset];
    
    bool should_draw = command.indexCount > 0;

    uvec4 should_draw_ballot = subgroupBallot(should_draw);
    uint total_should_draw_count = subgroupBallotBitCount(should_draw_ballot);

    uint compacted_buffer_index_base = 0;
    if (subgroupElect())
        compacted_buffer_index_base = atomicAdd(u_final_compact_command_count_buffer.count, total_should_draw_count);

    compacted_buffer_index_base = subgroupBroadcastFirst(compacted_buffer_index_base);

    uint compacted_buffer_offset = subgroupBallotExclusiveBitCount(should_draw_ballot);

    uint compacted_buffer_index = compacted_buffer_index_base + compacted_buffer_offset;

    if (should_draw)
        u_final_command_compact_buffer.commands[compacted_buffer_index] = command;
}