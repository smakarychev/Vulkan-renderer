#version 460

#include "common.shader_header"
#include "culling_functions.shader_header"

#extension GL_KHR_shader_subgroup_ballot: enable
#extension GL_KHR_shader_subgroup_vote: enable
#extension GL_KHR_shader_subgroup_clustered: enable
#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_atomic_int64: require

const uint TRIANGLES_PER_MESHLET = 256;
const uint MICRO_CLUSTER_SIZE = 8;

layout(local_size_x = 64) in;

layout(constant_id = 0) const bool REOCCLUSION = false;

@dynamic
layout(set = 0, binding = 0) uniform scene_data_buffer {
    scene_data scene;
} u_scene_data;

layout(set = 0, binding = 1) uniform sampler2D u_depth_pyramid;

layout(std430, set = 0, binding = 2) readonly buffer object_buffer {
    object_data objects[];
} u_object_buffer;

layout(std430, set = 0, binding = 3) readonly buffer meshlet_visibility_buffer{
    uint16_t visibility[];
} u_meshlet_visibility_buffer;

layout(std430, set = 0, binding = 4) readonly buffer positions_buffer {
    Position positions[];
} u_positions_buffer;

layout(std430, set = 0, binding = 5) readonly buffer indices_buffer {
    uint16_t indices[];
} u_indices_buffer;

layout(std430, set = 0, binding = 6) writeonly buffer culled_indices_buffer {
    uint16_t indices[];
} u_culled_indices_buffer;

layout(std430, set = 0, binding = 7) buffer visible_triangles_buffer {
    uint64_t visibility[];
} u_visible_triangles_buffer;

@dynamic
layout(std430, set = 0, binding = 8) buffer triangle_buffer {
    uint triangles[];
} u_triangle_buffer;

layout(std430, set = 0, binding = 9) buffer command_buffer {
    IndirectCommand commands[];
} u_command_buffer;

@dynamic
layout(std430, set = 0, binding = 10) buffer count_buffer {
    uint count;
} u_count_buffer;

layout(push_constant) uniform push_constants {
    uint u_screen_width;
    uint u_screen_height;
    uint u_triangle_offset;
    uint u_command_offset;
    uint u_max_command_index;
    uint u_max_draw_calls;
};

vec4 transform_to_NDC_and_get_aabb(inout Triangle triangle) {
    triangle.a.xyz /= triangle.a.w;
    triangle.b.xyz /= triangle.b.w;
    triangle.c.xyz /= triangle.c.w;

    float minx = min(triangle.a.x, min(triangle.b.x, triangle.c.x));
    float maxx = max(triangle.a.x, max(triangle.b.x, triangle.c.x));
    float miny = min(triangle.a.y, min(triangle.b.y, triangle.c.y));
    float maxy = max(triangle.a.y, max(triangle.b.y, triangle.c.y));

    vec4 aabb = vec4(minx, maxy, maxx, miny);
    aabb = aabb.xyzw * 0.5f + vec4(0.5f);
    
    return aabb;
}

bool is_visible(Triangle triangle) {
    bool visible = true;
    visible = visible && is_backface_triangle_visible(triangle);
    vec4 aabb = transform_to_NDC_and_get_aabb(triangle);
    visible = visible && is_screen_size_visible(aabb, u_screen_width, u_screen_height);
    visible = visible && is_frustum_triangle_visible(aabb);
    
    return visible;
}

bool is_reocclusion_visible(Triangle triangle) {
    bool visible = true;
    visible = visible && is_backface_triangle_visible(triangle);
    vec4 aabb = transform_to_NDC_and_get_aabb(triangle);
    visible = visible && is_screen_size_visible(aabb, u_screen_width, u_screen_height);
    visible = visible && is_frustum_triangle_visible(aabb);
    float depth = max(triangle.a.z, max(triangle.b.z, triangle.c.z));
    visible = visible && is_occlusion_triangle_visible(aabb, depth, u_scene_data.scene, u_depth_pyramid);
    
    return visible;
}

void compact(uint id, uint triangle_index, uvec3 indices, bool should_draw) {
    IndirectCommand command = u_command_buffer.commands[id];

    uint command_write_index = u_max_draw_calls - id - 1;
    
    uvec4 visible_ballot = subgroupBallot(should_draw);
    uint total_visible_triangle_count = subgroupBallotBitCount(visible_ballot);
    uint total_visible_count = total_visible_triangle_count * 3;

    uint compacted_index_offset = 0;
    if (subgroupElect()) {
        u_command_buffer.commands[command_write_index].firstInstance = command.firstInstance;
        u_command_buffer.commands[command_write_index].instanceCount = command.instanceCount;
        u_command_buffer.commands[command_write_index].vertexOffset = command.vertexOffset;
        u_command_buffer.commands[command_write_index].render_object = command.render_object;

        compacted_index_offset = atomicAdd(u_command_buffer.commands[command_write_index].indexCount, total_visible_count);

        u_command_buffer.commands[command_write_index].firstIndex = (id - u_command_offset) * TRIANGLES_PER_MESHLET * 3;
    }
    compacted_index_offset = subgroupBroadcastFirst(compacted_index_offset);

    if (should_draw) {
        uint compacted_buffer_offset = compacted_index_offset + subgroupBallotExclusiveBitCount(visible_ballot) * 3;
        uint compacted_buffer_index = u_command_buffer.commands[command_write_index].firstIndex + compacted_buffer_offset;
        u_culled_indices_buffer.indices[compacted_buffer_index + 0] = uint16_t(indices.x);
        u_culled_indices_buffer.indices[compacted_buffer_index + 1] = uint16_t(indices.y);
        u_culled_indices_buffer.indices[compacted_buffer_index + 2] = uint16_t(indices.z);

        u_triangle_buffer.triangles[compacted_buffer_index / 3] = triangle_index;
    }
}

void main() {
    uint id = gl_GlobalInvocationID.x / gl_WorkGroupSize.x;
    if (id >= u_max_command_index || id + u_command_offset >= u_count_buffer.count)
        return;
    id = id + u_command_offset;
    
    IndirectCommand command = u_command_buffer.commands[id];
   
    uint triangle_index = gl_LocalInvocationID.x + u_triangle_offset;
    uint index_offset = triangle_index * 3;

    if (index_offset >= command.indexCount)
        return;

    object_data object = u_object_buffer.objects[command.render_object];

    uvec3 indices = uvec3(
        u_indices_buffer.indices[command.firstIndex + index_offset + 0],
        u_indices_buffer.indices[command.firstIndex + index_offset + 1],
        u_indices_buffer.indices[command.firstIndex + index_offset + 2]);

    Triangle triangle;
    triangle.a = vec4_from_position(u_positions_buffer.positions[command.vertexOffset + uint(indices.x)]);
    triangle.b = vec4_from_position(u_positions_buffer.positions[command.vertexOffset + uint(indices.y)]);
    triangle.c = vec4_from_position(u_positions_buffer.positions[command.vertexOffset + uint(indices.z)]);

    // view_matrix is actually a view_projection_matrix
    triangle.a = u_scene_data.scene.view_matrix * object.model * triangle.a;
    triangle.b = u_scene_data.scene.view_matrix * object.model * triangle.b;
    triangle.c = u_scene_data.scene.view_matrix * object.model * triangle.c;

    uint meshlet_index = command.firstInstance;
    uint bitslot = triangle_index / MICRO_CLUSTER_SIZE;
    bool is_meshlet_drawn = flags_should_draw(u_meshlet_visibility_buffer.visibility[meshlet_index]);
    bool is_meshlet_visible = flags_visible(u_meshlet_visibility_buffer.visibility[meshlet_index]);
    bool is_last_frame_visible = (u_visible_triangles_buffer.visibility[meshlet_index] & (1 << bitslot)) != 0;
    bool should_be_drawn = false;
    bool visible = false;
    if (!REOCCLUSION) {
        visible = is_meshlet_drawn && is_last_frame_visible && is_visible(triangle);
        should_be_drawn = visible;
    } else {
        visible = is_meshlet_visible && is_reocclusion_visible(triangle);
        bool has_visible = is_meshlet_visible && subgroupClusteredOr(visible, MICRO_CLUSTER_SIZE);
        if ((triangle_index & MICRO_CLUSTER_SIZE - 1) == 0)
        {
            if (has_visible)
                atomicOr(u_visible_triangles_buffer.visibility[meshlet_index], (1 << bitslot));
            else
                atomicAnd(u_visible_triangles_buffer.visibility[meshlet_index], ~(1 << bitslot));
        }
        
        // determine based on 'visible' or 'has_visible'?
        should_be_drawn = !is_last_frame_visible && visible;
    }
    
    compact(id, triangle_index, indices, should_be_drawn);
}
