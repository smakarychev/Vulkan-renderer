#version 460

layout(local_size_x = 64) in;

struct VkDrawIndexedIndirectCommand {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;
};

@dynamic
layout(set = 0, binding = 0) uniform scene_data {
    vec4 frustum_planes[6];
    uint mesh_count;
    uint pad0;
    uint pad1;
    uint pad2;
} u_scene_data;

struct object_data{
    mat4 model;
    // bounding sphere
    float x; 
    float y;
    float z;
    float r;
};

layout(std430, set = 0, binding = 1) buffer readonly object_buffer {
    object_data objects[];
} u_object_buffer;

layout(std430, set = 0, binding = 2) buffer writeonly command_buffer {
    VkDrawIndexedIndirectCommand commands[];
} u_command_buffer;

float extract_scale(mat4 matrix)
{
    vec3 scales = vec3(dot(matrix[0], matrix[0]), dot(matrix[1], matrix[1]), dot(matrix[2], matrix[2]));
    return max(scales.x, max(scales.y, scales.z));
}

bool isVisible(uint id)
{
    object_data object = u_object_buffer.objects[id];
    
    vec3 origin = vec3(object.model * vec4(object.x, object.y, object.z, 1.0f));
    float radius = object.r * extract_scale(object.model);
    
    for (uint i = 0; i < 6; i++)
    {
        vec4 plane = u_scene_data.frustum_planes[i];
        if (dot(origin, plane.xyz) + plane.w + radius < 0)
            return false;
    }
    
    return true;
}

void main()
{
    uint id = gl_GlobalInvocationID.x;
    if (id >= u_scene_data.mesh_count)
        return;
    
    u_command_buffer.commands[id].instanceCount = int(isVisible(id));
}